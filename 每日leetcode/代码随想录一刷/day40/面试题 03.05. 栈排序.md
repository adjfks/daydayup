# 题目

> 栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。
> 
> 示例1:
> 
>  输入：
> ["SortedStack", "push", "push", "peek", "pop", "peek"]
> [[], [1], [2], [], [], []]
>  输出：
> [null,null,null,1,null,2]
> 示例2:
> 
>  输入： 
> ["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
> [[], [], [], [1], [], []]
>  输出：
> [null,null,null,null,null,true]
> 说明:
> 
> 栈中的元素数目在[0, 5000]范围内。
> 
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/sort-of-stacks-lcci
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



# 思路

方法一：利用额外辅助栈，注意push方法不要用构造函数原型上的方法，比如将元素移到辅助栈用原生数组的方法。





# 代码

```javascript
var SortedStack = function() {
    this.stack = []
    this.size = 0
    this.help = []
};

/** 
 * @param {number} val
 * @return {void}
 */
SortedStack.prototype.push = function(val) {
    // 栈为空或者val最小，直接入栈
    if(this.size === 0 || val <= this.peek()) {
        this.stack.push(val)
    }else {
        while(this.stack.length !== 0 && val > this.stack[this.stack.length - 1]){
            // 放入暂存栈中
            this.help.push(this.stack.pop())
        }
        this.stack.push(val)    // 加入val
        while(this.help.length !== 0){
            this.stack.push(this.help.pop())    // 将暂存栈元素还给栈
        }
    }
    // 元素总数加一
    this.size++
};

/**
 * @return {void}
 */
SortedStack.prototype.pop = function() {
    if(this.size === 0) return null
    this.size--
    return this.stack.pop()
};

/**
 * @return {number}
 */
SortedStack.prototype.peek = function() {
    if(this.size === 0) return -1
    return this.stack[this.size - 1]
};

/**
 * @return {boolean}
 */
SortedStack.prototype.isEmpty = function() {
    return this.size === 0
};

/**
 * Your SortedStack object will be instantiated and called as such:
 * var obj = new SortedStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.isEmpty()
 */
```
